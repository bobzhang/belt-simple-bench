(function () {
'use strict';

var out_of_memory = /* tuple */[
  "Out_of_memory",
  0
];

var sys_error = /* tuple */[
  "Sys_error",
  -1
];

var failure = /* tuple */[
  "Failure",
  -2
];

var invalid_argument = /* tuple */[
  "Invalid_argument",
  -3
];

var end_of_file = /* tuple */[
  "End_of_file",
  -4
];

var division_by_zero = /* tuple */[
  "Division_by_zero",
  -5
];

var not_found = /* tuple */[
  "Not_found",
  -6
];

var match_failure = /* tuple */[
  "Match_failure",
  -7
];

var stack_overflow = /* tuple */[
  "Stack_overflow",
  -8
];

var sys_blocked_io = /* tuple */[
  "Sys_blocked_io",
  -9
];

var assert_failure = /* tuple */[
  "Assert_failure",
  -10
];

var undefined_recursive_module = /* tuple */[
  "Undefined_recursive_module",
  -11
];

out_of_memory.tag = 248;

sys_error.tag = 248;

failure.tag = 248;

invalid_argument.tag = 248;

end_of_file.tag = 248;

division_by_zero.tag = 248;

not_found.tag = 248;

match_failure.tag = 248;

stack_overflow.tag = 248;

sys_blocked_io.tag = 248;

assert_failure.tag = 248;

undefined_recursive_module.tag = 248;


/*  Not a pure module */

/* No side effect */

/* No side effect */

/* No side effect */

/* No side effect */

/* No side effect */

/* No side effect */

/* No side effect */

function height(n) {
  if (n !== null) {
    return n.h;
  } else {
    return 0;
  }
}

function create(l, x, d, r) {
  var hl = height(l);
  var hr = height(r);
  return {
          left: l,
          key: x,
          value: d,
          right: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function singleton(x, d) {
  return {
          left: null,
          key: x,
          value: d,
          right: null,
          h: 1
        };
}

function updateValue(n, newValue) {
  if (n.value === newValue) {
    return n;
  } else {
    return {
            left: n.left,
            key: n.key,
            value: newValue,
            right: n.right,
            h: n.h
          };
  }
}

function bal(l, x, d, r) {
  var hl = l !== null ? l.h : 0;
  var hr = r !== null ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    var ll = l.left;
    var lv = l.key;
    var ld = l.value;
    var lr = l.right;
    if (height(ll) >= height(lr)) {
      return create(ll, lv, ld, create(lr, x, d, r));
    } else {
      var lrl = lr.left;
      var lrv = lr.key;
      var lrd = lr.value;
      var lrr = lr.right;
      return create(create(ll, lv, ld, lrl), lrv, lrd, create(lrr, x, d, r));
    }
  } else if (hr > (hl + 2 | 0)) {
    var rl = r.left;
    var rv = r.key;
    var rd = r.value;
    var rr = r.right;
    if (height(rr) >= height(rl)) {
      return create(create(l, x, d, rl), rv, rd, rr);
    } else {
      var rll = rl.left;
      var rlv = rl.key;
      var rld = rl.value;
      var rlr = rl.right;
      return create(create(l, x, d, rll), rlv, rld, create(rlr, rv, rd, rr));
    }
  } else {
    return {
            left: l,
            key: x,
            value: d,
            right: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
}

var empty = null;


/* No side effect */

function has$1(_n, x) {
  while(true) {
    var n = _n;
    if (n !== null) {
      var v = n.key;
      if (x === v) {
        return /* true */1;
      } else {
        _n = x < v ? n.left : n.right;
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  }
}


/* No side effect */

function set$1(t, newK, newD) {
  if (t !== null) {
    var k = t.key;
    if (newK === k) {
      return updateValue(t, newD);
    } else {
      var v = t.value;
      if (newK < k) {
        return bal(set$1(t.left, newK, newD), k, v, t.right);
      } else {
        return bal(t.left, k, v, set$1(t.right, newK, newD));
      }
    }
  } else {
    return singleton(newK, newD);
  }
}

var empty$1 = empty;

var has$2 = has$1;


/* No side effect */

// Generated by BUCKLESCRIPT VERSION 2.1.1, PLEASE EDIT WITH CARE
function check(b) {
  if (b) {
    return 0;
  } else {
    throw new Error("impossible");
  }
}

function test() {
  var m = empty$1;
  for(var i = 0; i <= 1000000; ++i){
    m = set$1(m, i, i);
  }
  for(var i$1 = 0; i$1 <= 1000000; ++i$1){
    check(has$2(m, i$1));
  }
  return /* () */0;
}

console.time("buckle");

test(/* () */0);

console.timeEnd("buckle");


/*  Not a pure module */

}());
